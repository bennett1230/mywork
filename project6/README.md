"# Project 6" 

# Project6--Google Password Checkup验证

## 摘要

  本实验基于 Google Password Checkup 功能的核心需求，实现了一种隐私保护的密码泄露检测方案。该方案参考论文《On Deploying Secure Computing: Private Intersection-Sum-with-Cardinality》中 Section 3.1 的 DDH（Decisional Diffie-Hellman）协议，通过椭圆曲线加密、Paillier 同态加密和随机化技术，在不泄露用户密码哈希和服务端泄露密码哈希的前提下，完成“用户密码是否在泄露集合中”的检测。实验结果表明，该方案能准确识别交集（泄露密码），且双方均无法从交互中获取额外隐私信息，符合隐私保护与功能正确性要求。

---

## 一、实验目的

  本实验旨在实现 Google Password Checkup 验证协议，参考论文 https://eprint.iacr.org/2019/723.pdf 的 Section 3.1（Figure 2），通过编程实现一种在保护双方隐私的前提下检测用户密码是否出现在泄露集合中的协议。

---

## 二、实验原理

### 2.1 核心需求与问题抽象

  Google Password Checkup 的核心需求是：用户P1持有自己的密码哈希集合，服务端P2持有已知泄露的密码哈希集合，双方需检测“用户密码哈希是否在泄露集合中”，即计算交集大小，但不得泄露任何一方原始哈希数据。

  该问题可抽象为“私有交集-基数与和”问题：
- P1输入：用户密码哈希集合V={v1,v2,···,Vm1}
- P2输入：泄露密码哈希集合及标记W={（w1,t1),(w2,t2),···,(wm2,tm2)}（其中tj=1表示“该哈希已泄漏”）
- 目标：双方获取交集大小c（共同哈希数量）和交集和S（∑tj，即泄露密码数量），不泄露其他信息。

### 2.2 关键密码学技术

#### 2.2.1 DDH假设与椭圆曲线加密

  DDH（判定性Diffie-Hellman）假设是协议安全性的基础：在椭圆曲线群中，给定g,ga,gb,无法区分gab与随机群元素。本实验使用NIST-P256椭圆曲线，通过“二次加密”隐藏哈希值：
- P1用私钥k1加密哈希：H(vi)k1（即将哈希值作为标量乘基点G，再乘k1）
- P2用私钥k2二次加密：H(vi)k1k2

#### 2.2.2 Paillier同态加密

  Paillier加密支持“密文加法对应明文加法”的同态特性，用于安全计算交集和：
1. P2加密tj得到AEnc(tj)
2. P1对交集对应的密文求和：ASum({AEnc(tj)})=AEnc(∑tj)
3. P2解密得到交集和S，无需暴露单个tj。

#### 2.2.3 随机化与打乱

  通过“打乱加密后数据的顺序”，隐藏元素对应关系：P1和P2在交互中均对加密后的哈希列表随机排序，避免对方通过顺序推断原始数据。

### 2.3 协议流程

1. **初始化**：P2生成Paillier密钥对并发送公钥给P1；双方生成DDH私钥k1,k2。
2. **第一轮（P1->P2）**：P1将用户哈希vi映射到椭圆曲线（用哈希值做标量乘基点G）->用k1加密->打乱后发送给P2。
3. **第二轮（P2->P1）**：P2用k2加密P1的消息->打乱后回发（用于交集比对）；P2将泄露哈希wj映射到曲线->用k2加密->结合AEnc(tj)->打乱后发送给P1。
4. **第三轮（P1->P2）**：P1用k1加密P2的泄露哈希->与P2回发的消息比对，找到交集；P1对交集对应的AEnc(tj)求和->发送加密结果给P2。
5. **结果**：P2解密得到交集和S，若S>0则表示存在泄露密码。

---

## 三、实验步骤

### 3.1 代码结构

- **create_leaked_hashes.py**：生成包含泄露密码哈希的文件
- **create_user_hashes.py**：生成包含用户密码哈希的文件
- **password_checkup_protocol.py**：协议核心（DDH、哈希映射、加密运算）
- **password_server.py**：服务端（P2）实现，存储泄露密码并参与协议
- **password_client.py**：用户端（P1）实现，处理用户密码并参与协议
- **union.py**：整合文件，便于演示验证过程

### 3.2 实验步骤

#### 3.2.1 生成密码哈希文件
- Step1：运行 create_leaked_hashes.py 生成包含泄露密码哈希的文件 leaked_hashes.txt。
- Step2：运行 create_user_hashes.py 生成包含用户密码哈希的文件 user_hashes.txt。

#### 3.2.2 启动协议流程
- Step3：运行 main.py，模拟客户端和服务端的协议交互，完成密码泄露检测。

---

## 四、实验结果分析

### 4.1 功能正确性

  在实验中，设置了包含泄露密码的用户密码列表和泄露密码列表。运行协议后，程序能够正确识别出用户密码中存在的泄露密码，返回的交集和S大于0，表明方案能够准确检测出“用户密码是否在泄露集合中”，满足功能正确性要求。
  
  用户密码表：
  ```python
'qwerty', 'mypassword', 'letmein'
```

泄露密码表：
```python
'123456', 'password', 'letmein', 'qwerty'
```

### 4.2 隐私保护

  由于采用了椭圆曲线加密、Paillier同态加密和随机化技术，在整个协议交互过程中，双方均无法从交互中获取额外隐私信息。椭圆曲线加密通过二次加密隐藏了哈希值，Paillier同态加密在计算交集和时无需暴露单个标记值，随机化技术打乱了加密数据的顺序，避免了通过顺序推断原始数据，符合隐私保护要求。

---

## 五、实验结论

  本实验实现了基于椭圆曲线和Paillier同态加密的Google Password Checkup协议，能够在保护双方隐私的前提下，准确检测用户密码是否出现在泄露集合中，验证了协议的正确性和安全性。
